# Keel Flows Reference Guide

This document provides a comprehensive guide to Keel flows - multi-step operations that orchestrate complex, sequential processes combining automated backend work with interactive user interfaces.

## Table of Contents

- [What Are Flows?](#what-are-flows)
- [Getting Started](#getting-started)
  - [Project Structure](#project-structure)
  - [Development Workflow](#development-workflow)
- [Core Concepts](#core-concepts)
- [Defining Flows](#defining-flows)
- [Flow Steps](#flow-steps)
- [UI Elements](#ui-elements)
- [Configuration Options](#configuration-options)
- [Error Handling and Retries](#error-handling-and-retries)
- [Testing Flows](#testing-flows)
- [Best Practices](#best-practices)

## What Are Flows?

Flows are multi-step operations in Keel that handle complex, sequential processes beyond simple CRUD operations. They combine:

- **Automated backend logic** - Using function steps for data manipulation and business logic
- **Interactive user interfaces** - Using UI steps to collect input or display information
- **Durability** - Automatic retries and state persistence
- **Resumability** - Ability to continue from where they left off after interruptions

### Common Use Cases

- Employee onboarding workflows
- Order refund processing
- Invoice management
- Approval workflows requiring user sign-off
- External system integrations
- Multi-step data collection forms

## Getting Started

### Project Structure

Flows are defined in your Keel project with a specific file structure:

```
my-keel-project/
├── schema.keel              # Your schema with flow declarations
├── flows/                   # Flow implementation directory
│   ├── processOrder.ts      # Individual flow files
│   ├── onboardEmployee.ts
│   └── approveInvoice.ts
├── functions/               # Regular Keel functions
├── tests/                   # Test files (flows tested here)
│   └── flows.test.ts
└── keelconfig.yaml          # Keel configuration
```

#### Flow Files Location

- **Flow implementations** go in the `flows/` directory at the root of your project
- Each flow is a separate TypeScript file
- File names should match your flow names (camelCase recommended)
- The file exports the flow implementation using the generated flow constructor

#### Schema Declaration

First, declare your flow in `schema.keel`:

```keel
model Order {
  fields {
    customerId Text
    total Decimal
    status Text
  }
}

flow ProcessOrder {
  inputs {
    orderId ID
    customerId Text
  }
  @permission(expression: ctx.identity.user.role == "Manager")
}
```

#### Generated Types

After declaring the flow in your schema, run:

```bash
keel generate
```

This generates:
- TypeScript types for your flow inputs
- Flow constructor function (`ProcessOrder`)
- Type-safe context objects
- All necessary imports in `@teamkeel/sdk`

#### Implementation File

Create the implementation in `flows/processOrder.ts`:

```typescript
import { ProcessOrder, models } from "@teamkeel/sdk";

export default ProcessOrder(
  {
    title: "Process Order",
    description: "Handle order processing and fulfillment",
  },
  async (ctx, inputs) => {
    // Flow implementation
    const order = await ctx.step("validate order", async () => {
      return await models.order.findOne({ id: inputs.orderId });
    });

    // More steps...
  }
);
```

**Key points**:
- Import the flow constructor from `@teamkeel/sdk` (generated by `keel generate`)
- Export as `default` - required for Keel to find your flow
- First parameter is optional configuration (title, description, stages)
- Second parameter is the async flow function with `(ctx, inputs)` signature
- `inputs` is typed based on your schema declaration

#### File Naming Conventions

**Recommended approach**:
```
schema.keel:  flow ProcessOrder { }
flow file:    flows/processOrder.ts
export:       export default ProcessOrder({ }, async (ctx, inputs) => { })
```

**Important**:
- Flow names in schema are typically PascalCase
- File names are typically camelCase (but not enforced)
- The export must use the generated constructor name (PascalCase)

### Development Workflow

#### 1. Define Flow in Schema

Add your flow declaration to `schema.keel`:

```keel
flow OnboardEmployee {
  inputs {
    employeeId ID
    departmentName Text
    startDate Date
  }
  @permission(roles: [Admin])
}
```

#### 2. Generate TypeScript Types

Run the generator to create TypeScript definitions:

```bash
keel generate
```

This creates the `OnboardEmployee` constructor and types for your inputs.

#### 3. Implement Your Flow

Create `flows/onboardEmployee.ts`:

```typescript
import { OnboardEmployee, models } from "@teamkeel/sdk";

export default OnboardEmployee(
  {
    title: "Employee Onboarding",
    stages: [
      { key: "setup", name: "Account Setup" },
      { key: "training", name: "Training" },
    ],
  },
  async (ctx, inputs) => {
    // Create employee account
    const account = await ctx.step("create account", { stage: "setup" }, async () => {
      return await models.employee.create({
        id: inputs.employeeId,
        department: inputs.departmentName,
        startDate: inputs.startDate,
      });
    });

    // Collect training preferences
    const preferences = await ctx.ui.page("training preferences", {
      title: "Select Your Training Tracks",
      content: [
        ctx.ui.select.one("track", {
          label: "Training Track",
          options: ["Engineering", "Product", "Sales"],
        }),
      ],
    });

    // Assign training
    await ctx.step("assign training", { stage: "training" }, async () => {
      return await models.training.create({
        employeeId: account.id,
        track: preferences.track,
      });
    });
  }
);
```

#### 4. Run Your Keel Project Locally

Start the Keel development server:

```bash
keel run
```

This:
- Starts the local Keel server
- Watches for file changes
- Makes your flows available via API
- Provides a local database

#### 5. Access Your Flow

Flows can be accessed programmatically via the generated client or directly via API endpoints. During development, you can:

**Via API**:
```bash
# Start a flow
curl -X POST http://localhost:8000/api/flows/onboardEmployee/start \
  -H "Content-Type: application/json" \
  -d '{"employeeId": "emp-123", "departmentName": "Engineering", "startDate": "2025-01-15"}'

# Get flow state
curl http://localhost:8000/api/flows/onboardEmployee/runs/{flowId}

# Submit UI step values
curl -X POST http://localhost:8000/api/flows/onboardEmployee/runs/{flowId}/steps/{stepId}/values \
  -H "Content-Type: application/json" \
  -d '{"track": "Engineering"}'
```

**Via generated client** (in your tests or other code):
```typescript
import { flows } from "@teamkeel/sdk";

const flow = await flows.onboardEmployee.start({
  employeeId: "emp-123",
  departmentName: "Engineering",
  startDate: new Date("2025-01-15"),
});
```

#### 6. Write Tests

**Critical**: Tests are run with the `keel test` command.

Create `tests/flows.test.ts`:

```typescript
import { resetDatabase, flows } from "@teamkeel/testing";
import { beforeEach, expect, test } from "vitest";

beforeEach(resetDatabase);

test("onboard employee flow", async () => {
  // Start the flow
  const flow = await flows.onboardEmployee.start({
    employeeId: "emp-123",
    departmentName: "Engineering",
    startDate: new Date("2025-01-15"),
  });

  // Wait for UI step
  const atUI = await flows.onboardEmployee.untilAwaitingInput(flow.id);
  expect(atUI.status).toBe("AWAITING_INPUT");
  expect(atUI.steps[1].ui.title).toBe("Select Your Training Tracks");

  // Submit user input
  const completed = await flows.onboardEmployee.putStepValues(
    flow.id,
    atUI.steps[1].id,
    { track: "Engineering" }
  );

  // Wait for completion
  const final = await flows.onboardEmployee.untilFinished(completed.id);
  expect(final.status).toBe("COMPLETED");
});
```

#### 7. Run Tests

Run your flow tests using:

```bash
keel test
```

**Important**: You must use `keel test` to run flow tests, not `vitest` or `npm test` directly. The `keel test` command:
- Sets up the test database
- Configures the test environment correctly
- Provides the necessary test utilities (`@teamkeel/testing`)
- Handles flow execution in test mode

**Test output**:
```bash
$ keel test

 ✓ tests/flows.test.ts (1)
   ✓ onboard employee flow

 Test Files  1 passed (1)
      Tests  1 passed (1)
   Start at  10:30:15
   Duration  2.34s
```

**Test options**:
```bash
# Run specific test file
keel test tests/flows.test.ts

# Run tests matching pattern
keel test --grep "onboard"

# Watch mode (re-run on changes)
keel test --watch

# Verbose output
keel test --verbose
```

#### 8. Iterate and Debug

**Common development cycle**:

1. Modify your flow in `flows/onboardEmployee.ts`
2. Save the file (Keel will detect changes if `keel run` is running)
3. Run `keel test` to verify your changes
4. Check test output for errors or failures
5. Repeat

**Debugging tips**:
- Use `console.log()` in your flow steps - output appears in `keel run` logs
- Check step `error` fields in test assertions
- Use `keel test --verbose` for more detailed output
- Remember: flow body re-executes, so logs outside steps appear multiple times

**Testing individual steps**:
```typescript
test("validate order step", async () => {
  const flow = await flows.processOrder.start({
    orderId: "order-123",
    customerId: "cust-456",
  });

  const completed = await flows.processOrder.untilFinished(flow.id);

  // Check specific step result
  const validateStep = completed.steps.find(s => s.name === "validate order");
  expect(validateStep.status).toBe("COMPLETED");
  expect(validateStep.value).toMatchObject({
    orderId: "order-123",
    isValid: true,
  });
});
```

#### 9. Regenerate After Schema Changes

Whenever you modify flow declarations in `schema.keel`:

```bash
# 1. Update schema.keel
# 2. Regenerate types
keel generate
# 3. Update your flow implementation if inputs changed
# 4. Update tests if necessary
# 5. Run tests to verify
keel test
```

**Example**: Adding a new input field:

```keel
flow OnboardEmployee {
  inputs {
    employeeId ID
    departmentName Text
    startDate Date
    managerId ID  // New field added
  }
  @permission(roles: [Admin])
}
```

After `keel generate`, your TypeScript will show:
```typescript
// TypeScript now requires managerId
const flow = await flows.onboardEmployee.start({
  employeeId: "emp-123",
  departmentName: "Engineering",
  startDate: new Date("2025-01-15"),
  managerId: "mgr-001",  // Now required by TypeScript
});
```

#### 10. Deployment

When ready to deploy:

```bash
# Run tests to ensure everything works
keel test

# Deploy to your Keel environment
keel deploy
```

Your flows are now live and accessible via your Keel API.

## Core Concepts

### Flow Lifecycle

1. **Start**: Flow is initiated with optional input parameters
2. **Running**: Function steps execute asynchronously via a queue
3. **Awaiting Input**: Flow pauses at UI steps waiting for user interaction
4. **Completed**: All steps finish successfully
5. **Failed**: Flow or step exhausts retry attempts
6. **Cancelled**: Flow is manually cancelled

### Flow Execution Model

**Critical Concept**: The flow function body **always re-executes from the beginning** every time the flow resumes. However, previously completed steps do not re-execute - they immediately return their cached results.

This execution model is fundamental to understanding how flows work:

#### How It Works

```typescript
export default MyFlow({}, async (ctx, inputs) => {
  console.log("Flow body starts"); // This runs EVERY time

  // First step
  const result1 = await ctx.step("step 1", async () => {
    console.log("Executing step 1");
    return await createOrder();
  });

  console.log("Between steps"); // This runs EVERY time

  // Second step
  const result2 = await ctx.step("step 2", async () => {
    console.log("Executing step 2");
    return await processPayment(result1.orderId);
  });

  console.log("Flow body ends"); // This runs EVERY time
});
```

**What happens in practice**:

1. **First execution** (after `start()`):
   - `"Flow body starts"` logs
   - `"Executing step 1"` logs
   - Step 1 creates an order
   - Function body exits, step 1 queued for execution

2. **Second execution** (after step 1 completes):
   - `"Flow body starts"` logs again ⚠️
   - `await ctx.step("step 1")` immediately returns cached result (no re-execution)
   - `"Between steps"` logs
   - `"Executing step 2"` logs
   - Step 2 processes payment
   - Function body exits, step 2 queued for execution

3. **Third execution** (after step 2 completes):
   - `"Flow body starts"` logs again ⚠️
   - Step 1 returns cached result
   - `"Between steps"` logs
   - Step 2 returns cached result
   - `"Flow body ends"` logs
   - Flow completes

#### Key Implications

1. **Code between steps runs multiple times**: Any code outside `ctx.step()` or `ctx.ui.page()` will execute on every resume.

2. **Don't perform side effects outside steps**: Database writes, API calls, etc. should only happen inside steps:

   ```typescript
   // ❌ BAD - will execute multiple times
   await models.log.create({ message: "Flow started" });
   await ctx.step("do work", async () => { /* ... */ });

   // ✅ GOOD - only executes once
   await ctx.step("log start", async () => {
     await models.log.create({ message: "Flow started" });
   });
   await ctx.step("do work", async () => { /* ... */ });
   ```

3. **Use step results for flow logic**: You can safely use completed step results to make decisions:

   ```typescript
   const validation = await ctx.step("validate", async () => {
     return { isValid: true, customerId: "123" };
   });

   // This condition is evaluated on every resume
   if (validation.isValid) {
     await ctx.step("process", async () => {
       // Process for customer 123
     });
   }
   ```

4. **UI steps also return cached results**: When a UI step completes, subsequent re-executions immediately return the user's submitted values:

   ```typescript
   const userData = await ctx.ui.page("collect info", {
     content: [ctx.ui.inputs.text("name", { label: "Name" })]
   });
   // After user submits, userData = { name: "John" }
   // On next resume, this immediately returns { name: "John" }
   ```

#### Why This Design?

This model enables several powerful features:
- **Resumability**: Flow can pause at any step and resume exactly where it left off
- **Durability**: No data loss if the system restarts - cached results persist
- **Conditional logic**: You can use step results to determine which steps to execute next
- **Simplicity**: Write linear code that looks synchronous, framework handles complexity

**Important**: This is why you should never rely on in-memory variables across step boundaries - they reset on each execution. Only data returned from steps is guaranteed to persist.

### Step Durability

- Each step executes successfully only once
- Results persist and return to the flow body on completion
- If failures occur, steps automatically retry
- Individual steps have a 15-minute execution timeout
- Total flow duration is unlimited across multiple steps

## Defining Flows

### Schema Definition

Flows are declared in your Keel schema using the `flow` keyword:

```keel
// Basic flow
flow ProcessOrder {
  @permission(roles: [Manager])
}

// Flow with inputs
flow OnboardEmployee {
  inputs {
    employeeId ID
    departmentName Text
    startDate Date
  }
  @permission(roles: [Admin])
}

// Flow with expression permissions
flow ApproveInvoice {
  @permission(expression: ctx.identity.user.role == "Finance")
}
```

### TypeScript Implementation

After defining a flow in the schema, run `keel generate` to scaffold the TypeScript implementation:

```typescript
import { ProcessOrder, models } from "@teamkeel/sdk";

export default ProcessOrder(
  {
    // Optional configuration
    title: "Process Order",
    description: "Handles order processing and fulfillment",
    stages: [
      {
        key: "validation",
        name: "Validation",
        description: "Validate order details",
      },
      {
        key: "fulfillment",
        name: "Fulfillment",
        description: "Process and ship order",
      },
    ],
  },
  async (ctx, inputs) => {
    // Flow implementation
  }
);
```

## Flow Steps

### Function Steps

Function steps execute backend logic and are durable:

```typescript
// Basic function step
const orderId = await ctx.step("create order", async () => {
  const order = await models.order.create({
    customerId: inputs.customerId,
    total: inputs.total,
  });
  return order.id;
});

// Function step with stage
await ctx.step(
  "validate payment",
  { stage: "validation" },
  async () => {
    const payment = await validatePaymentMethod(inputs.paymentId);
    return payment.isValid;
  }
);

// Function step with retry configuration
await ctx.step(
  "call external api",
  {
    retries: 3,
    retryPolicy: RetryLinear(2) // 2s, 4s, 6s delays
  },
  async (args) => {
    // args.attempt contains the current attempt number
    const response = await externalAPI.call();
    return response.data;
  }
);

// Function step with failure callback
await ctx.step(
  "process payment",
  {
    retries: 2,
    onFailure: async () => {
      // Cleanup logic on permanent failure
      await models.order.update(
        { id: orderId },
        { status: "payment_failed" }
      );
    },
  },
  async () => {
    await processPayment(inputs.paymentId);
  }
);
```

**Important**: All return values from function steps must be JSON-serializable.

### UI Steps (Pages)

UI steps pause flow execution and display interfaces to users:

```typescript
// Basic page with input
const values = await ctx.ui.page("confirm details", {
  title: "Confirm Your Details",
  description: "Please review and confirm the information",
  content: [
    ctx.ui.inputs.text("name", {
      label: "Full Name",
      defaultValue: inputs.name,
    }),
    ctx.ui.inputs.number("age", {
      label: "Age",
    }),
  ],
});

// Access returned values
console.log(values.name); // user-entered name
console.log(values.age); // user-entered age

// Page with actions (simple string format - label and value are the same)
const { data, action } = await ctx.ui.page("approval", {
  title: "Approve Request",
  content: [
    ctx.ui.display.markdown({
      content: "Review the request details below"
    }),
    ctx.ui.inputs.text("comments", {
      label: "Comments",
      optional: true,
    }),
  ],
  actions: ["approve", "reject"],
});

if (action === "approve") {
  // Handle approval
} else {
  // Handle rejection
}

// Page with custom action objects (label displayed to user, value returned to code)
const { data, action } = await ctx.ui.page("approval", {
  title: "Approve Request",
  content: [...],
  actions: [
    {
      label: "Approve",     // What the user sees
      value: "complete",    // What your code receives in 'action'
      mode: "primary",
    },
    {
      label: "Reject",
      value: "reject",
      mode: "destructive",
    },
  ],
});

if (action === "complete") {  // IMPORTANT: Use the 'value', not the 'label'
  // Handle approval
} else if (action === "reject") {
  // Handle rejection
}

// Page with back navigation
await ctx.ui.page("review", {
  title: "Review Information",
  content: [...],
  allowBack: true, // Enables back button
});
```

### Completion Pages

Return a custom completion page instead of the default:

```typescript
return ctx.complete({
  title: "Order Processed",
  description: "Your order has been successfully processed",
  stage: "fulfillment",
  content: [
    ctx.ui.display.markdown({
      content: "Thank you for your order!"
    }),
    ctx.ui.display.keyValue({
      data: { "Order ID": orderId, "Status": "Completed" },
    }),
  ],
  data: {
    orderId: orderId,
    completedAt: new Date(),
  },
});
```

## UI Elements

### Input Elements

#### Text Input
```typescript
ctx.ui.inputs.text("fieldName", {
  label: "Field Label",
  placeholder: "Enter text...",
  defaultValue: "initial value",
  optional: false,
  disabled: false,
  validate: (value) => {
    if (value.length < 3) {
      return "Must be at least 3 characters";
    }
    return true;
  },
})
```

#### Number Input
```typescript
ctx.ui.inputs.number("quantity", {
  label: "Quantity",
  defaultValue: 1,
  optional: false,
  validate: (value) => {
    if (value < 1) return "Must be positive";
    if (value > 100) return "Maximum 100 allowed";
    return true;
  },
})
```

#### Boolean Input
```typescript
ctx.ui.inputs.boolean("agreed", {
  label: "I agree to the terms",
  mode: "checkbox", // or "toggle"
  validate: (value) => {
    if (!value) return "You must agree to continue";
    return true;
  },
})
```

#### Date Picker
```typescript
ctx.ui.inputs.datePicker("startDate", {
  label: "Start Date",
  optional: false,
})
```

#### Scan Input
```typescript
// Single scan
ctx.ui.inputs.scan("barcode", {
  mode: "single",
  duplicateHandling: "none",
})

// Bulk scan
ctx.ui.inputs.scan("barcodes", {
  mode: "multi",
  duplicateHandling: "rejectDuplicates", // or "acceptDuplicates"
  autoContinue: false,
})
```

### Display Elements

#### Markdown
```typescript
ctx.ui.display.markdown({
  content: "# Header\n\n**Bold text** and *italic text*",
})
```

#### Header
```typescript
ctx.ui.display.header({
  title: "Section Title",
  description: "Section description",
  level: 1, // 1-6
})
```

#### Divider
```typescript
ctx.ui.display.divider()
```

#### Code
```typescript
ctx.ui.display.code({
  content: "const x = 10;",
  language: "javascript",
})
```

#### Banner
```typescript
ctx.ui.display.banner({
  content: "Important notice",
  mode: "info", // "info", "warning", "error", "success"
})
```

#### Key-Value
```typescript
ctx.ui.display.keyValue({
  data: {
    "Order ID": "12345",
    "Customer": "John Doe",
    "Total": "$99.99",
  },
})
```

#### List
```typescript
ctx.ui.display.list({
  data: ["Item 1", "Item 2", "Item 3"],
})
```

#### Table
```typescript
ctx.ui.display.table({
  data: [
    { id: 1, name: "Product A", price: 10 },
    { id: 2, name: "Product B", price: 20 },
  ],
  columns: [
    { key: "id", label: "ID" },
    { key: "name", label: "Product Name" },
    { key: "price", label: "Price" },
  ],
})
```

#### Grid
```typescript
ctx.ui.display.grid({
  data: products,
  render: (product) => ({
    title: product.name,
    description: product.description,
    image: product.imageUrl,
  }),
})
```

#### Image
```typescript
ctx.ui.display.image({
  src: "https://example.com/image.jpg",
  alt: "Description",
})
```

### Selection Elements

#### Select One
```typescript
ctx.ui.select.one("category", {
  label: "Category",
  options: ["Electronics", "Clothing", "Food", "Other"],
  optional: false,
})
```

#### Pick List
```typescript
const values = await ctx.ui.page("select items", {
  title: "Select Items",
  content: [
    ctx.ui.pickList("selectedItems", {
      data: items,
      render: (item) => ({
        title: item.name,
        description: item.description,
      }),
      validate: (selected) => {
        if (selected.length === 0) {
          return "Select at least one item";
        }
        return true;
      },
    }),
  ],
});
```

#### Data Grid
```typescript
ctx.ui.dataGrid("inventory", {
  data: products,
  columns: [
    { key: "sku", label: "SKU" },
    { key: "name", label: "Name" },
    { key: "quantity", label: "Quantity" },
  ],
})
```

### Iterator Element

Create repeating form sections:

```typescript
const values = await ctx.ui.page("order items", {
  title: "Order Items",
  content: [
    ctx.ui.iterator("items", {
      min: 1,
      max: 10,
      content: [
        ctx.ui.select.one("sku", {
          label: "Product",
          options: ["SHOES", "SHIRTS", "PANTS"],
        }),
        ctx.ui.inputs.number("quantity", {
          label: "Quantity",
          validate: (value) => {
            if (value < 1) return "Must be at least 1";
            return true;
          },
        }),
      ],
      validate: (items) => {
        // Validate the entire collection
        const skus = items.map(item => item.sku);
        const duplicates = skus.filter((s, i) => skus.indexOf(s) !== i);
        if (duplicates.length > 0) {
          return "Duplicate SKUs are not allowed";
        }
        return true;
      },
    }),
  ],
});

// values.items will be an array of { sku, quantity } objects
```

### Element Callbacks

Elements can have callbacks for real-time interactions:

```typescript
const values = await ctx.ui.page("dynamic form", {
  content: [
    ctx.ui.inputs.number("quantity", {
      label: "Quantity",
      defaultValue: 1,
      onLeave: async (value, ctx) => {
        // Called when user leaves the field
        // Return a new value or the same value
        return value * 2;
      },
    }),
  ],
});
```

## Configuration Options

### Flow Configuration

```typescript
export default MyFlow(
  {
    title: "Flow Title",
    description: "Flow description for documentation",
    stages: [
      {
        key: "stage1",
        name: "Stage 1 Name",
        description: "What happens in stage 1",
      },
      {
        key: "stage2",
        name: "Stage 2 Name",
        description: "What happens in stage 2",
      },
    ],
  },
  async (ctx, inputs) => {
    // Implementation
  }
);
```

### Step Configuration

```typescript
await ctx.step(
  "step name",
  {
    stage: "stage1", // Optional: associate with a stage
    retries: 3, // Number of retry attempts (default varies)
    retryPolicy: RetryLinear(2), // Retry delay policy
    onFailure: async () => {
      // Cleanup on permanent failure
    },
  },
  async (args) => {
    // args.attempt contains current attempt number
    // Step implementation
  }
);
```

### Page Validation

```typescript
await ctx.ui.page("form", {
  title: "Form Title",
  content: [...],
  validate: async (values) => {
    // Page-level validation
    if (!values.email && !values.phone) {
      return "Either email or phone is required";
    }
    return true;
  },
});
```

## Error Handling and Retries

### Retry Policies

Keel provides several retry policies:

```typescript
import {
  RetryConstant,
  RetryLinear,
  RetryExponential
} from "@teamkeel/sdk";

// Constant delay: 2s between each retry
RetryConstant(2)

// Linear backoff: 2s, 4s, 6s, 8s...
RetryLinear(2)

// Exponential backoff: 2s, 4s, 8s, 16s...
RetryExponential(2)

// Custom delays per attempt
await ctx.step(
  "complex operation",
  {
    retries: 3,
    retryPolicy: {
      delays: [3, 1, 2] // First retry after 3s, second after 1s, third after 2s
    }
  },
  async () => {
    // Implementation
  }
);
```

### Error Handling in Steps

**Default Retry Behavior**: By default, function steps will retry 4 times (5 total attempts including the original) before failing permanently.

```typescript
await ctx.step(
  "risky operation",
  {
    retries: 2,  // Override default: 2 retries (3 total attempts)
    onFailure: async () => {
      // Called after all retries are exhausted
      await cleanupResources();
      await notifyAdministrators();
    },
  },
  async (args) => {
    try {
      const result = await externalAPI.call();
      return result;
    } catch (error) {
      // Error will trigger a retry
      throw new Error(`API call failed: ${error.message}`);
    }
  }
);
```

### Preventing Retries

To prevent retrying on certain errors (bypasses all retry logic):

```typescript
import { DoNotRetryError } from "@teamkeel/sdk";

await ctx.step("validate input", async () => {
  if (!isValid(input)) {
    // This error will NOT be retried - fails immediately
    throw new DoNotRetryError("Invalid input format");
  }
  return processInput(input);
});
```

**Important**: When a `DoNotRetryError` is thrown, the step fails immediately with only 1 attempt (no retries), and the flow status becomes `FAILED` with error message `"flow failed due to exhausted step retries"`.

### Flow-Level Errors

Errors thrown outside steps will immediately fail the flow with no steps created:

```typescript
export default MyFlow({}, async (ctx, inputs) => {
  // This error fails the flow immediately (no retries, no steps)
  if (!inputs.requiredField) {
    throw new Error("Required field is missing");
  }

  // This error will be retried (inside a step)
  await ctx.step("process", async () => {
    throw new Error("Processing failed");
  });
});
```

**Result**: Flow status becomes `FAILED`, `error` field contains the error message, and `steps` array is empty `[]`.

## Testing Flows

### Test Setup

```typescript
import { resetDatabase, models, flows } from "@teamkeel/testing";
import { beforeEach, expect, test } from "vitest";

beforeEach(resetDatabase);
```

### Flow and Step Data Structures

Understanding the shape of flow and step objects is essential for writing effective tests.

#### Flow Object Structure

```typescript
interface FlowRun {
  id: string;                    // Unique flow run identifier
  traceId: string;               // Trace ID for debugging
  name: string;                  // Flow name (e.g., "ProcessOrder")
  status: FlowStatus;            // Current flow status
  startedBy: string | null;      // Identity ID of who started the flow
  input: object;                 // Input parameters passed to the flow
  error: string | null;          // Error message if flow failed
  data: object | null;           // Data returned from flow (via ctx.complete)
  steps: Step[];                 // Array of all steps in this flow run
  config: FlowConfig;            // Flow configuration (title, description, stages)
  createdAt: Date;               // When flow was created
  updatedAt: Date;               // When flow was last updated
}

type FlowStatus =
  | "RUNNING"          // Flow is executing function steps
  | "AWAITING_INPUT"   // Flow is paused at a UI step waiting for user input
  | "COMPLETED"        // Flow finished successfully
  | "FAILED"           // Flow failed permanently
  | "CANCELLED";       // Flow was cancelled by user

interface FlowConfig {
  title?: string;
  description?: string;
  stages?: Array<{
    key: string;
    name: string;
    description: string;
  }>;
}
```

#### Step Object Structure

```typescript
interface Step {
  id: string;                    // Unique step identifier
  runId: string;                 // Flow run ID this step belongs to
  name: string;                  // Step name (from ctx.step or ctx.ui.page)
  stage: string | null;          // Stage key if associated with a stage
  status: StepStatus;            // Current step status
  type: StepType;                // Type of step
  value: any | null;             // Result/value from the step
  error: string | null;          // Error message if step failed
  startTime: Date | null;        // When step started executing
  endTime: Date | null;          // When step finished
  createdAt: Date;               // When step was created
  updatedAt: Date;               // When step was last updated
  ui: UIPage | null;             // UI configuration (only populated for pending UI steps)
  allowBack?: boolean;           // Whether back navigation is allowed (also in ui.allowBack)
}

type StepStatus =
  | "NEW"        // Function step created but not yet started (queued)
  | "PENDING"    // UI step waiting for user input
  | "RUNNING"    // Function step currently executing (rare to see in tests)
  | "COMPLETED"  // Step finished successfully
  | "FAILED"     // Step failed permanently after retries
  | "CANCELLED"; // Step was cancelled

type StepType =
  | "FUNCTION"   // Backend function step (ctx.step)
  | "UI"         // User interface step (ctx.ui.page)
  | "COMPLETE";  // Completion step (ctx.complete) - has empty name ""
```

#### UI Object Structure

The `ui` field is **only populated when a UI step is in PENDING status**. Once the step completes, `ui` becomes `null`.

```typescript
interface UIPage {
  __type: "ui.page";
  title?: string;
  description?: string;
  hasValidationErrors: boolean;          // True if any validation failed
  validationError?: string;              // Page-level validation error message
  allowBack?: boolean;                   // Whether back button is enabled
  actions?: Array<{                      // Custom action buttons
    label: string;
    mode: "primary" | "secondary";
    value: string;
  }>;
  content: UIElement[];                  // Array of UI elements
}

// UI elements have different shapes based on __type
type UIElement =
  | UIInputText
  | UIInputNumber
  | UIInputBoolean
  | UIInputDatePicker
  | UIInputScan
  | UIDisplayMarkdown
  | UIDisplayHeader
  | UIDisplayDivider
  | UIDisplayKeyValue
  | UIDisplayTable
  | UIDisplayGrid
  | UIDisplayImage
  | UIDisplayCode
  | UIDisplayBanner
  | UISelectOne
  | UIIterator
  | UIPickList
  | UIDataGrid;

// Example input element
interface UIInputText {
  __type: "ui.input.text";
  name: string;
  label: string;
  placeholder?: string;
  defaultValue?: string;
  optional: boolean;
  disabled: boolean;
  validationError?: string;              // Element-level validation error
}

// Example display element
interface UIDisplayMarkdown {
  __type: "ui.display.markdown";
  content: string;
}

// Iterator element (special - contains nested content with validation)
interface UIIterator {
  __type: "ui.iterator";
  name: string;
  min?: number;
  max?: number;
  content: UIElement[];                   // Elements within each iteration
  validationError?: string;               // Iterator-level validation error
  contentValidationErrors?: Array<{       // Validation errors for specific items
    index: number;                        // Which iteration (0-based)
    name: string;                         // Which field in that iteration
    validationError: string;              // The error message
  }>;
}
```

### When the `ui` Field is Populated vs Null

**CRITICAL RULE**: The `ui` field on a step is **only populated when**:
- Step `type` is `"UI"`
- Step `status` is `"PENDING"`

**The `ui` field is `null` when**:
- Step `type` is `"FUNCTION"` (always null for function steps)
- Step `status` is `"COMPLETED"` (UI configuration removed after completion)
- Step `status` is `"FAILED"` or `"CANCELLED"`

**Exception**: Steps of type `"COMPLETE"` have a special `ui` object with `__type: "ui.complete"` even after completion.

**Important for Validation Errors**: If a validation function throws an error (rather than returning an error string), the UI step will transition to `FAILED` status with `ui: null` and the error message in the `error` field. This is different from returning a validation error string, which keeps the step `PENDING` with `ui` populated.

```typescript
// Example: Function step (ui is always null)
{
  type: "FUNCTION",
  status: "NEW",
  ui: null  // ← Always null for function steps
}

// Example: UI step awaiting input (ui is populated)
{
  type: "UI",
  status: "PENDING",
  ui: {  // ← Populated with page configuration
    __type: "ui.page",
    title: "Enter Details",
    content: [...]
  }
}

// Example: UI step after completion (ui becomes null)
{
  type: "UI",
  status: "COMPLETED",
  value: { name: "John" },  // User-provided values stored here
  ui: null  // ← UI config removed after completion
}

// Example: Completion step (special case)
{
  type: "COMPLETE",
  status: "COMPLETED",
  ui: {  // ← Still populated even when completed
    __type: "ui.complete",
    title: "Flow Complete",
    content: [...]
  }
}
```

### Step Types and Statuses Reference

Understanding step types and statuses is crucial for writing correct test assertions.

#### Step Types

| Type       | Description                                      | When Created                                       | UI Field                                        |
| ---------- | ------------------------------------------------ | -------------------------------------------------- | ----------------------------------------------- |
| `FUNCTION` | Backend function step created with `ctx.step()`  | When flow execution reaches a `ctx.step()` call    | Always `null`                                   |
| `UI`       | User interface step created with `ctx.ui.page()` | When flow execution reaches a `ctx.ui.page()` call | Populated when `PENDING`, `null` when completed |
| `COMPLETE` | Completion step created with `ctx.complete()`    | When flow returns `ctx.complete()`                 | Populated even when `COMPLETED`                 |

#### Step Statuses

| Status      | Applies To | Meaning                                                          | Next State                 |
| ----------- | ---------- | ---------------------------------------------------------------- | -------------------------- |
| `NEW`       | `FUNCTION` | Function step created but not yet started (queued for execution) | `COMPLETED` or `FAILED`    |
| `PENDING`   | `UI`       | UI step waiting for user input via `putStepValues()`             | `COMPLETED` or `CANCELLED` |
| `RUNNING`   | `FUNCTION` | Function step currently executing (rare to observe in tests)     | `COMPLETED` or `FAILED`    |
| `COMPLETED` | All types  | Step finished successfully                                       | Terminal state             |
| `FAILED`    | `FUNCTION` | Step failed permanently after exhausting all retries             | Terminal state             |
| `CANCELLED` | All types  | Step was cancelled by user                                       | Terminal state             |

#### Flow Statuses

| Status           | Meaning                          | Typical Step States                                        |
| ---------------- | -------------------------------- | ---------------------------------------------------------- |
| `RUNNING`        | Flow is executing function steps | At least one `FUNCTION` step is `NEW` or `RUNNING`         |
| `AWAITING_INPUT` | Flow paused at a UI step         | At least one `UI` step is `PENDING`                        |
| `COMPLETED`      | Flow finished successfully       | All steps are `COMPLETED`                                  |
| `FAILED`         | Flow failed permanently          | At least one step is `FAILED`, or flow body threw an error |
| `CANCELLED`      | Flow was cancelled               | At least one step is `CANCELLED`                           |

#### Common State Combinations

```typescript
// Flow just started with function step
{
  flow: { status: "RUNNING" },
  step: { type: "FUNCTION", status: "NEW", ui: null }
}

// Function step completed, UI step now pending
{
  flow: { status: "AWAITING_INPUT" },
  step1: { type: "FUNCTION", status: "COMPLETED", ui: null },
  step2: { type: "UI", status: "PENDING", ui: { /* populated */ } }
}

// UI step completed after user input
{
  flow: { status: "RUNNING" },  // May continue to next step
  step: { type: "UI", status: "COMPLETED", value: { /* user input */ }, ui: null }
}

// Function step failed after retries
{
  flow: { status: "FAILED", error: "flow failed due to exhausted step retries" },
  step: { type: "FUNCTION", status: "FAILED", error: "Error message" }
}

// Flow completed with completion page
{
  flow: { status: "COMPLETED", data: { /* returned data */ } },
  finalStep: { type: "COMPLETE", status: "COMPLETED", ui: { __type: "ui.complete", /* ... */ } }
}
```

#### Step Timing Fields

| Field       | Populated When                      | Example Value              |
| ----------- | ----------------------------------- | -------------------------- |
| `createdAt` | Always (when step is first created) | `2024-01-15T10:30:00.000Z` |
| `updatedAt` | Always (updated on any change)      | `2024-01-15T10:30:05.000Z` |
| `startTime` | When step starts executing          | `2024-01-15T10:30:01.000Z` |
| `endTime`   | When step completes/fails/cancels   | `2024-01-15T10:30:04.000Z` |

```typescript
// NEW function step (not started yet)
{
  startTime: null,
  endTime: null,
  createdAt: Date,
  updatedAt: Date
}

// COMPLETED function step
{
  startTime: Date,  // When execution began
  endTime: Date,    // When it completed
  createdAt: Date,  // When it was queued
  updatedAt: Date   // When it last changed
}

// PENDING UI step
{
  startTime: Date,  // When it became pending
  endTime: null,    // Not finished yet
  createdAt: Date,
  updatedAt: Date
}
```

### Test Framework API Methods

#### `flows.<flowName>.start(inputs)`

Starts a new flow run.

**Returns**: Immediate snapshot of the flow run.

**When to use**: To initiate a flow and get its initial state.

**Behavior**:
- If the flow has no steps or starts with a UI step, it completes synchronously
- If the first step is a function step, it returns with that step in `"NEW"` status
- The function step will be executed asynchronously via a queue

```typescript
// Flow starting with function step
const flow = await flows.processOrder.withAuthToken(token).start({ orderId: "123" });
expect(flow.status).toBe("RUNNING");
expect(flow.steps[0].status).toBe("NEW");     // Not executed yet
expect(flow.steps[0].type).toBe("FUNCTION");
expect(flow.steps[0].ui).toBe(null);

// Flow starting with UI step
const flow2 = await flows.onboarding.start({});
expect(flow2.status).toBe("AWAITING_INPUT");
expect(flow2.steps[0].status).toBe("PENDING");
expect(flow2.steps[0].type).toBe("UI");
expect(flow2.steps[0].ui).toBeDefined();      // UI config is present
```

#### `flows.<flowName>.get(flowId)`

Gets the current state of a flow run.

**Returns**: Current snapshot of the flow run.

**When to use**: To check the current state without waiting.

```typescript
const flow = await flows.myFlow.get(flowId);
console.log(flow.status);  // Current status
console.log(flow.steps.length);  // Number of steps so far
```

#### `flows.<flowName>.untilFinished(flowId, timeout?)`

Polls the flow until it reaches a terminal state (`COMPLETED`, `FAILED`, or `CANCELLED`).

**Returns**: Promise that resolves with the final flow state.

**When to use**: When you need to wait for all function steps to complete.

**Timeout**: Optional timeout in milliseconds (default: 10000ms / 10 seconds).

```typescript
const flow = await flows.processOrder.withAuthToken(token).start({ orderId: "123" });
expect(flow.status).toBe("RUNNING");

// Wait for all function steps to complete
const completed = await flows.processOrder
  .withAuthToken(token)
  .untilFinished(flow.id, 30000);  // Wait up to 30 seconds

expect(completed.status).toBe("COMPLETED");
expect(completed.steps).toHaveLength(3);

// All function steps should be completed
completed.steps.forEach(step => {
  if (step.type === "FUNCTION") {
    expect(step.status).toBe("COMPLETED");
    expect(step.value).toBeDefined();
    expect(step.startTime).toBeDefined();
    expect(step.endTime).toBeDefined();
  }
});
```

#### `flows.<flowName>.untilAwaitingInput(flowId, timeout?)`

Polls the flow until it reaches `AWAITING_INPUT` status (paused at a UI step).

**Returns**: Promise that resolves when a UI step is pending.

**When to use**: After starting a flow, when you need to wait for it to reach a UI step.

**Timeout**: Optional timeout in milliseconds (default: 10000ms / 10 seconds).

```typescript
const flow = await flows.mixedFlow.withAuthToken(token).start({ name: "Test" });

// Flow starts with a function step
expect(flow.status).toBe("RUNNING");
expect(flow.steps[0].type).toBe("FUNCTION");
expect(flow.steps[0].status).toBe("NEW");

// Wait for function step to complete and flow to reach UI step
const atUI = await flows.mixedFlow
  .withAuthToken(token)
  .untilAwaitingInput(flow.id);

expect(atUI.status).toBe("AWAITING_INPUT");
expect(atUI.steps[0].status).toBe("COMPLETED");      // First function step done
expect(atUI.steps[1].type).toBe("UI");
expect(atUI.steps[1].status).toBe("PENDING");
expect(atUI.steps[1].ui).toBeDefined();              // UI config is present
```

#### `flows.<flowName>.putStepValues(flowId, stepId, values, action?)`

Submits user input for a pending UI step.

**Parameters**:
- `flowId`: The flow run ID
- `stepId`: The specific step ID (must be a pending UI step)
- `values`: Object with field names and values matching the UI inputs
- `action`: Optional action value if the page has custom actions

**Returns**: Updated flow state after processing the input.

**Behavior**:
- If validation fails: Returns flow with `status: "AWAITING_INPUT"`, step remains `"PENDING"`, `ui` field contains validation errors
- If validation passes: Step transitions to `"COMPLETED"`, `ui` becomes `null`, `value` contains the user input
- If the page has actions and an action is provided, it bypasses validation (unless you specify action-specific validation)

```typescript
// Submit input to a pending UI step
const flow = await flows.registration.start({});
expect(flow.steps[0].status).toBe("PENDING");

// Submit values
const updated = await flows.registration.putStepValues(
  flow.id,
  flow.steps[0].id,
  {
    email: "user@example.com",
    name: "John Doe"
  }
);

// If validation passed
expect(updated.steps[0].status).toBe("COMPLETED");
expect(updated.steps[0].value).toEqual({
  email: "user@example.com",
  name: "John Doe"
});
expect(updated.steps[0].ui).toBe(null);  // UI config removed

// If validation failed
expect(updated.steps[0].status).toBe("PENDING");  // Still pending
expect(updated.steps[0].ui.hasValidationErrors).toBe(true);
expect(updated.steps[0].ui.content[0].validationError).toBeDefined();
```

#### `flows.<flowName>.back(flowId)`

Navigates back to the previous UI step (if `allowBack: true`).

**Returns**: Updated flow state with the previous step reset to `PENDING`.

**When to use**: To test back navigation functionality.

```typescript
const flow = await flows.wizard.start({});

// Complete first step
const step1Complete = await flows.wizard.putStepValues(
  flow.id,
  flow.steps[0].id,
  { field1: "value1" }
);

expect(step1Complete.steps).toHaveLength(2);
expect(step1Complete.steps[1].status).toBe("PENDING");

// Go back
const backToStep1 = await flows.wizard.back(flow.id);

expect(backToStep1.steps).toHaveLength(1);
expect(backToStep1.steps[0].status).toBe("PENDING");
expect(backToStep1.steps[0].ui).toBeDefined();  // UI config present again
```

#### `flows.<flowName>.cancel(flowId)`

Cancels a running flow.

**Returns**: Flow state with `status: "CANCELLED"`.

**When to use**: To test flow cancellation.

```typescript
const flow = await flows.longRunning.start({});

const atUI = await flows.longRunning.untilAwaitingInput(flow.id);
expect(atUI.steps[0].status).toBe("PENDING");

// Cancel the flow
const cancelled = await flows.longRunning.cancel(flow.id);

expect(cancelled.status).toBe("CANCELLED");
expect(cancelled.steps[0].status).toBe("CANCELLED");
expect(cancelled.steps[0].ui).toBe(null);  // UI config removed
```

### Starting a Flow

```typescript
test("flow execution", async () => {
  const token = await getAuthToken({ email: "user@example.com" });

  // Start the flow
  const flow = await flows.myFlow
    .withAuthToken(token)
    .start({
      inputParam: "value",
    });

  expect(flow.status).toBe("RUNNING"); // or "AWAITING_INPUT"
  expect(flow.id).toBeDefined();
  expect(flow.steps).toHaveLength(1);
});
```

### Testing Function Steps

```typescript
test("function steps complete", async () => {
  const token = await getAuthToken({ email: "admin@keel.xyz" });

  const flow = await flows.processOrder
    .withAuthToken(token)
    .start({ orderId: "123" });

  // Wait for flow to complete
  const completed = await flows.processOrder
    .withAuthToken(token)
    .untilFinished(flow.id);

  expect(completed.status).toBe("COMPLETED");
  expect(completed.steps).toHaveLength(3);
  expect(completed.steps[0].status).toBe("COMPLETED");
  expect(completed.steps[0].value).toEqual({
    orderId: "123",
    processed: true,
  });
});
```

### Testing UI Steps

```typescript
test("ui steps and user interaction", async () => {
  const flow = await flows.onboarding.start({});

  // Flow pauses at first UI step
  expect(flow.status).toBe("AWAITING_INPUT");
  expect(flow.steps[0].type).toBe("UI");
  expect(flow.steps[0].status).toBe("PENDING");
  expect(flow.steps[0].ui).toBeDefined();

  // Inspect UI configuration
  expect(flow.steps[0].ui.title).toBe("Employee Details");
  expect(flow.steps[0].ui.content).toHaveLength(2);
  expect(flow.steps[0].ui.content[0].__type).toBe("ui.input.text");

  // Provide user input
  const updated = await flows.onboarding.putStepValues(
    flow.id,
    flow.steps[0].id,
    {
      name: "John Doe",
      email: "john@example.com",
    }
  );

  expect(updated.steps[0].status).toBe("COMPLETED");
  expect(updated.steps[0].value).toEqual({
    name: "John Doe",
    email: "john@example.com",
  });
});
```

### Testing Actions

```typescript
test("page actions", async () => {
  const flow = await flows.approval.start({});

  expect(flow.steps[0].ui.actions).toEqual([
    { label: "Approve", mode: "primary", value: "approve" },
    { label: "Reject", mode: "primary", value: "reject" },
  ]);

  // Submit with action
  // IMPORTANT: Use the action's 'value' field, NOT the 'label'
  const updated = await flows.approval.putStepValues(
    flow.id,
    flow.steps[0].id,
    { comments: "Looks good" },
    "approve" // action VALUE (must match action.value, not action.label)
  );

  expect(updated.steps[0].value).toEqual({
    comments: "Looks good",
  });

  // In the flow implementation, access action via:
  // const { data, action } = await ctx.ui.page(...)
  // action will be "approve" or "reject"
});
```

**Common Mistake**: Using the action's `label` instead of `value`:

```typescript
// Flow defines action with different label and value
actions: [
  {
    label: "Approve",   // User-facing text
    value: "complete",  // Internal value
    mode: "primary",
  },
]

// ❌ WRONG - Using the label
await flows.myFlow.putStepValues(flowId, stepId, values, "Approve");
// Result: Validation error "invalid action"

// ✅ CORRECT - Using the value
await flows.myFlow.putStepValues(flowId, stepId, values, "complete");
```

### Interrogating the UI Object

When a UI step is pending, you can interrogate the `ui` object to assert what the user interface should display.

#### Inspecting Page Structure

```typescript
test("inspect UI structure", async () => {
  const flow = await flows.onboarding.start({});

  const uiStep = flow.steps[0];

  // Assert page-level properties
  expect(uiStep.ui.__type).toBe("ui.page");
  expect(uiStep.ui.title).toBe("Employee Details");
  expect(uiStep.ui.description).toBe("Enter the new employee information");
  expect(uiStep.ui.hasValidationErrors).toBe(false);

  // Assert number of elements
  expect(uiStep.ui.content).toHaveLength(3);

  // Assert specific element types
  expect(uiStep.ui.content[0].__type).toBe("ui.input.text");
  expect(uiStep.ui.content[1].__type).toBe("ui.input.number");
  expect(uiStep.ui.content[2].__type).toBe("ui.select.one");
});
```

#### Inspecting Input Element Properties

```typescript
test("inspect input elements", async () => {
  const flow = await flows.registration.start({});

  const textInput = flow.steps[0].ui.content[0];

  // Assert input element properties
  expect(textInput.__type).toBe("ui.input.text");
  expect(textInput.name).toBe("email");
  expect(textInput.label).toBe("Email Address");
  expect(textInput.placeholder).toBe("you@example.com");
  expect(textInput.defaultValue).toBeUndefined();
  expect(textInput.optional).toBe(false);
  expect(textInput.disabled).toBe(false);
  expect(textInput.validationError).toBeUndefined();  // No error yet
});
```

#### Inspecting Actions

```typescript
test("inspect page actions", async () => {
  const flow = await flows.approval.start({});

  // Assert actions are present
  expect(flow.steps[0].ui.actions).toBeDefined();
  expect(flow.steps[0].ui.actions).toHaveLength(2);

  // Assert action properties
  expect(flow.steps[0].ui.actions[0]).toEqual({
    label: "Approve",
    mode: "primary",
    value: "approve"
  });

  expect(flow.steps[0].ui.actions[1]).toEqual({
    label: "Reject",
    mode: "primary",
    value: "reject"
  });
});
```

### Testing Validation

Validation errors can appear at multiple levels: page-level, element-level, and iterator-level.

#### Element-Level Validation

```typescript
test("element validation errors", async () => {
  const flow = await flows.registration.start({});

  // Submit invalid data
  const withErrors = await flows.registration.putStepValues(
    flow.id,
    flow.steps[0].id,
    {
      email: "invalid-email",
      postcode: "bad format"
    }
  );

  // Step remains PENDING with validation errors
  expect(withErrors.steps[0].status).toBe("PENDING");
  expect(withErrors.steps[0].ui.hasValidationErrors).toBe(true);

  // Find the email input element
  const emailInput = withErrors.steps[0].ui.content.find(
    el => el.__type === "ui.input.text" && el.name === "email"
  );

  // Assert element-level validation error
  expect(emailInput.validationError).toBe("Invalid email format");

  // Find the postcode input
  const postcodeInput = withErrors.steps[0].ui.content.find(
    el => el.__type === "ui.input.text" && el.name === "postcode"
  );

  expect(postcodeInput.validationError).toBe("not a valid postcode");

  // Submit valid data
  const fixed = await flows.registration.putStepValues(
    flow.id,
    flow.steps[0].id,
    {
      email: "user@example.com",
      postcode: "E4 6ED"
    }
  );

  expect(fixed.steps[0].status).toBe("COMPLETED");
  expect(fixed.steps[0].ui).toBe(null);  // UI removed after completion
  expect(fixed.steps[0].value).toEqual({
    email: "user@example.com",
    postcode: "E4 6ED"
  });
});
```

#### Page-Level Validation

```typescript
test("page-level validation errors", async () => {
  const flow = await flows.contact.start({});

  // Submit empty form where at least one field is required
  const withErrors = await flows.contact.putStepValues(
    flow.id,
    flow.steps[0].id,
    {}
  );

  expect(withErrors.steps[0].status).toBe("PENDING");
  expect(withErrors.steps[0].ui.hasValidationErrors).toBe(true);

  // Page-level validation error (not tied to a specific element)
  expect(withErrors.steps[0].ui.validationError).toBe(
    "Email or phone is required"
  );

  // Elements themselves don't have validation errors
  const emailInput = withErrors.steps[0].ui.content.find(
    el => el.name === "email"
  );
  expect(emailInput.validationError).toBeUndefined();
});
```

#### Combined Page and Element Validation

```typescript
test("multiple validation error levels", async () => {
  const flow = await flows.complexForm.start({});

  const withErrors = await flows.complexForm.putStepValues(
    flow.id,
    flow.steps[0].id,
    {
      email: "bad-format"  // Invalid format AND missing phone
    }
  );

  expect(withErrors.steps[0].ui.hasValidationErrors).toBe(true);

  // Page-level error
  expect(withErrors.steps[0].ui.validationError).toBe(
    "Email or phone is required"
  );

  // Element-level error
  const emailInput = withErrors.steps[0].ui.content.find(
    el => el.name === "email"
  );
  expect(emailInput.validationError).toBe("Not a valid email");
});
```

#### Iterator Validation Errors

Iterators have three levels of validation errors:

```typescript
test("iterator validation errors", async () => {
  const flow = await flows.orderItems.start({});

  // Submit with various errors
  const withErrors = await flows.orderItems.putStepValues(
    flow.id,
    flow.steps[0].id,
    {
      "items": [
        { sku: "SHOES", quantity: 1 },
        { sku: "SHIRTS", quantity: 0 },      // Too low
        { sku: "SHIRTS", quantity: 30 },     // Too high and duplicate
      ]
    }
  );

  expect(withErrors.steps[0].status).toBe("PENDING");
  expect(withErrors.steps[0].ui.hasValidationErrors).toBe(true);

  // Find the iterator element
  const iterator = withErrors.steps[0].ui.content.find(
    el => el.__type === "ui.iterator"
  );

  // 1. Page-level validation (overall)
  expect(withErrors.steps[0].ui.validationError).toBe(
    "Total quantity must be less than 20"
  );

  // 2. Iterator-level validation (about the collection)
  expect(iterator.validationError).toBe(
    "SHIRTS has been selected twice"
  );

  // 3. Content validation errors (specific items/fields)
  expect(iterator.contentValidationErrors).toHaveLength(2);

  expect(iterator.contentValidationErrors[0]).toEqual({
    index: 1,                          // Second item (0-based)
    name: "quantity",                  // Field name
    validationError: "Quantity must be greater than 0"
  });

  expect(iterator.contentValidationErrors[1]).toEqual({
    index: 2,                          // Third item
    name: "quantity",
    validationError: "Quantity must be less than 10"
  });
});
```

#### Action-Based Validation Bypass

```typescript
test("actions can bypass validation", async () => {
  const flow = await flows.approvalWithCancel.start({});

  // Provide the "cancel" action - validation is bypassed
  const cancelled = await flows.approvalWithCancel.putStepValues(
    flow.id,
    flow.steps[0].id,
    {
      email: "invalid-email"  // Invalid, but doesn't matter with cancel action
    },
    "cancel"  // Action bypasses validation
  );

  // Step completes even with invalid data
  expect(cancelled.steps[0].status).toBe("COMPLETED");
  expect(cancelled.steps[0].value).toEqual({
    email: "invalid-email"
  });

  // But using "next" action would validate
  const flow2 = await flows.approvalWithCancel.start({});
  const validated = await flows.approvalWithCancel.putStepValues(
    flow2.id,
    flow2.steps[0].id,
    {
      email: "invalid-email"
    },
    "next"  // This action triggers validation
  );

  expect(validated.steps[0].status).toBe("PENDING");
  expect(validated.steps[0].ui.hasValidationErrors).toBe(true);
});
```

### Testing Back Navigation

```typescript
test("back navigation", async () => {
  const flow = await flows.wizard.start({});

  // Complete first page
  await flows.wizard.putStepValues(flow.id, flow.steps[0].id, {
    step1Data: "value",
  });

  // Get flow at second page
  const atStep2 = await flows.wizard.get(flow.id);
  expect(atStep2.steps).toHaveLength(2);
  expect(atStep2.steps[1].status).toBe("PENDING");

  // Go back
  const backToStep1 = await flows.wizard.back(flow.id);

  expect(backToStep1.steps).toHaveLength(1);
  expect(backToStep1.steps[0].status).toBe("PENDING");
});
```

### Testing Error Handling

```typescript
test("step retries", async () => {
  const flow = await flows.withRetries.start({});

  const completed = await flows.withRetries.untilFinished(flow.id, 30000);

  // Check retry attempts
  const retriedSteps = completed.steps.filter(
    s => s.name === "failing step"
  );
  expect(retriedSteps).toHaveLength(4); // initial + 3 retries
  expect(retriedSteps[0].status).toBe("FAILED");
  expect(retriedSteps[1].status).toBe("FAILED");
  expect(retriedSteps[2].status).toBe("FAILED");
  expect(retriedSteps[3].status).toBe("COMPLETED");
});

test("flow failure", async () => {
  const flow = await flows.alwaysFails.start({});

  const failed = await flows.alwaysFails.untilFinished(flow.id);

  expect(failed.status).toBe("FAILED");
  expect(failed.error).toBe("flow failed due to exhausted step retries");
});
```

### Testing Cancellation

```typescript
test("flow cancellation", async () => {
  const flow = await flows.longRunning.start({});

  // Wait for UI step
  const atUI = await flows.longRunning.untilAwaitingInput(flow.id);

  // Cancel the flow
  const cancelled = await flows.longRunning.cancel(flow.id);

  expect(cancelled.status).toBe("CANCELLED");
  expect(cancelled.steps[0].status).toBe("CANCELLED");
});
```

### Testing Flow Queries

```typescript
test("list flows", async () => {
  const token = await getAuthToken({ email: "admin@keel.xyz" });

  // Start multiple flows
  await flows.flow1.withAuthToken(token).start({});
  await flows.flow2.withAuthToken(token).start({});

  // List user's flow runs
  const runs = await flows.flow1.withAuthToken(token).myRuns({
    status: "COMPLETED",
  });

  expect(runs).toBeArrayOfSize(1);
});

test("flow statistics", async () => {
  const token = await getAuthToken({ email: "admin@keel.xyz" });

  const stats = await getFlowStats(token, { interval: "daily" });

  expect(stats[0]).toMatchObject({
    name: "ProcessOrder",
    totalRuns: 5,
    activeRuns: 2,
    completedToday: 3,
    errorRate: 0.2,
  });
});
```

### Testing Element Callbacks

```typescript
test("element callbacks", async () => {
  const flow = await flows.callbackFlow.start({});

  const stepId = flow.steps[0].id;

  // Call element callback
  const response = await flows.callbackFlow.callback(
    flow.id,
    stepId,
    "quantity", // element name
    "onLeave", // callback name
    10 // input value
  );

  expect(response).toBe(20); // doubled by callback
});
```

### Testing Complete Flow Execution

Here's a comprehensive example testing a flow from start to finish with mixed step types.

```typescript
test("complete flow execution with mixed steps", async () => {
  const token = await getAuthToken({ email: "admin@keel.xyz" });

  // 1. Start the flow
  const flow = await flows.orderProcessing
    .withAuthToken(token)
    .start({ orderId: "ORD-123", customerId: "CUST-456" });

  // 2. Assert initial state - first step is a function
  expect(flow.status).toBe("RUNNING");
  expect(flow.id).toBeDefined();
  expect(flow.steps).toHaveLength(1);
  expect(flow.steps[0].type).toBe("FUNCTION");
  expect(flow.steps[0].status).toBe("NEW");
  expect(flow.steps[0].name).toBe("validate order");
  expect(flow.steps[0].ui).toBe(null);

  // 3. Wait for function step to complete and reach UI step
  const atUI = await flows.orderProcessing
    .withAuthToken(token)
    .untilAwaitingInput(flow.id);

  // 4. Assert flow reached UI step
  expect(atUI.status).toBe("AWAITING_INPUT");
  expect(atUI.steps).toHaveLength(2);

  // First step should be completed
  expect(atUI.steps[0].status).toBe("COMPLETED");
  expect(atUI.steps[0].type).toBe("FUNCTION");
  expect(atUI.steps[0].value).toEqual({
    orderId: "ORD-123",
    isValid: true,
  });
  expect(atUI.steps[0].ui).toBe(null);

  // Second step should be pending UI
  expect(atUI.steps[1].type).toBe("UI");
  expect(atUI.steps[1].status).toBe("PENDING");
  expect(atUI.steps[1].name).toBe("confirm shipping");
  expect(atUI.steps[1].ui).toBeDefined();

  // 5. Inspect UI configuration
  expect(atUI.steps[1].ui.__type).toBe("ui.page");
  expect(atUI.steps[1].ui.title).toBe("Confirm Shipping Details");
  expect(atUI.steps[1].ui.hasValidationErrors).toBe(false);
  expect(atUI.steps[1].ui.content).toHaveLength(2);

  // 6. Submit user input with validation error
  let updated = await flows.orderProcessing
    .withAuthToken(token)
    .putStepValues(atUI.id, atUI.steps[1].id, {
      address: "", // Invalid - required
      method: "EXPRESS",
    });

  // 7. Assert validation failed
  expect(updated.status).toBe("AWAITING_INPUT");
  expect(updated.steps[1].status).toBe("PENDING");
  expect(updated.steps[1].ui.hasValidationErrors).toBe(true);

  const addressInput = updated.steps[1].ui.content.find(
    (el) => el.name === "address"
  );
  expect(addressInput.validationError).toBe("Address is required");

  // 8. Submit valid input
  updated = await flows.orderProcessing
    .withAuthToken(token)
    .putStepValues(updated.id, updated.steps[1].id, {
      address: "123 Main St",
      method: "EXPRESS",
    });

  // 9. Assert UI step completed, flow continues
  expect(updated.status).toBe("RUNNING");
  expect(updated.steps[1].status).toBe("COMPLETED");
  expect(updated.steps[1].value).toEqual({
    address: "123 Main St",
    method: "EXPRESS",
  });
  expect(updated.steps[1].ui).toBe(null); // UI removed after completion

  // 10. Next function step should be queued
  expect(updated.steps).toHaveLength(3);
  expect(updated.steps[2].type).toBe("FUNCTION");
  expect(updated.steps[2].status).toBe("NEW");
  expect(updated.steps[2].name).toBe("process payment");

  // 11. Wait for all remaining steps to complete
  const completed = await flows.orderProcessing
    .withAuthToken(token)
    .untilFinished(updated.id, 30000);

  // 12. Assert final state
  expect(completed.status).toBe("COMPLETED");
  expect(completed.error).toBe(null);
  expect(completed.steps).toHaveLength(4);

  // All steps should be completed
  completed.steps.forEach((step) => {
    expect(step.status).toBe("COMPLETED");
    expect(step.startTime).toBeDefined();
    expect(step.endTime).toBeDefined();
  });

  // 13. Assert final step values
  const paymentStep = completed.steps[2];
  expect(paymentStep.name).toBe("process payment");
  expect(paymentStep.value).toEqual({
    transactionId: expect.any(String),
    amount: 99.99,
  });

  const shipStep = completed.steps[3];
  expect(shipStep.name).toBe("ship order");
  expect(shipStep.value).toEqual({
    trackingNumber: expect.any(String),
    carrier: "EXPRESS",
  });

  // 14. Verify database state
  const order = await models.order.findOne({ id: "ORD-123" });
  expect(order.status).toBe("SHIPPED");
  expect(order.trackingNumber).toBeDefined();
});
```

### Testing Flow with Retry and Recovery

```typescript
test("flow with retries and eventual success", async () => {
  const token = await getAuthToken({ email: "admin@keel.xyz" });

  const flow = await flows.unreliableOperation
    .withAuthToken(token)
    .start({ attemptToSucceedOn: 3 });

  // Wait for flow to complete (including retries)
  const completed = await flows.unreliableOperation
    .withAuthToken(token)
    .untilFinished(flow.id, 30000);

  expect(completed.status).toBe("COMPLETED");

  // Find all steps with same name (original + retries)
  const allAttempts = completed.steps.filter(
    (s) => s.name === "unreliable api call"
  );

  // Should have 3 failed attempts + 1 successful
  expect(allAttempts).toHaveLength(4);

  // First 3 attempts failed
  expect(allAttempts[0].status).toBe("FAILED");
  expect(allAttempts[0].error).toBeDefined();
  expect(allAttempts[1].status).toBe("FAILED");
  expect(allAttempts[2].status).toBe("FAILED");

  // Fourth attempt succeeded
  expect(allAttempts[3].status).toBe("COMPLETED");
  expect(allAttempts[3].value).toBeDefined();

  // Verify retry delays were applied
  const delay1 = allAttempts[1].startTime - allAttempts[1].createdAt;
  const delay2 = allAttempts[2].startTime - allAttempts[2].createdAt;

  expect(delay1).toBeGreaterThan(2000); // At least 2 seconds
  expect(delay2).toBeGreaterThan(2000);
});
```

### Waiting Utilities

```typescript
// Wait for flow to complete
await flows.myFlow.untilFinished(flowId, timeout);

// Wait for flow to reach UI step
await flows.myFlow.untilAwaitingInput(flowId, timeout);

// Get current flow state
const flow = await flows.myFlow.get(flowId);
```

### Quick Reference: When to Use Each Method

| Method                                         | When to Use                             | What It Does                                      | Returns                                         |
| ---------------------------------------------- | --------------------------------------- | ------------------------------------------------- | ----------------------------------------------- |
| `start(inputs)`                                | To begin a flow                         | Initiates flow execution                          | Immediate snapshot (first step may be `NEW`)    |
| `get(flowId)`                                  | To check current state                  | Gets latest flow state without waiting            | Current flow snapshot                           |
| `untilFinished(flowId)`                        | After starting flow with function steps | Polls until `COMPLETED`, `FAILED`, or `CANCELLED` | Final flow state                                |
| `untilAwaitingInput(flowId)`                   | After starting flow that has UI steps   | Polls until flow reaches `AWAITING_INPUT` status  | Flow state at UI step                           |
| `putStepValues(flowId, stepId, values)`        | When flow is at a UI step               | Submits user input for pending UI step            | Updated flow state (may have validation errors) |
| `putStepValues(..., action)`                   | When UI step has custom actions         | Submits input with specific action selected       | Updated flow state                              |
| `back(flowId)`                                 | To test back navigation                 | Returns to previous UI step                       | Flow state with previous step `PENDING`         |
| `cancel(flowId)`                               | To test cancellation                    | Cancels running flow                              | Flow state with `CANCELLED` status              |
| `callback(flowId, stepId, name, event, value)` | To test element callbacks               | Triggers element callback (e.g., `onLeave`)       | Callback return value                           |

### Testing Decision Tree

```
Starting a flow?
├─ Has function steps? → use start() then untilFinished() or untilAwaitingInput()
└─ Only UI steps? → use start() (returns AWAITING_INPUT immediately)

At a UI step?
├─ Want to inspect UI? → check step.ui properties
├─ Want to submit input? → use putStepValues()
└─ Want to go back? → use back()

Waiting for completion?
├─ Next step is function? → use untilFinished()
├─ Next step is UI? → use untilAwaitingInput()
└─ Want to check now? → use get()

Testing validation?
├─ Submit invalid data → putStepValues() → check step.ui.hasValidationErrors
├─ Check element errors → find element in step.ui.content[i].validationError
├─ Check page errors → check step.ui.validationError
└─ Check iterator errors → check iterator.validationError and contentValidationErrors

Testing errors?
├─ Function step errors → check step.status === "FAILED" and step.error
├─ Flow errors → check flow.status === "FAILED" and flow.error
└─ Retry behavior → filter steps by name, check multiple FAILED followed by COMPLETED
```

## Best Practices

### 1. Keep Steps Focused

Each step should have a single responsibility:

```typescript
// Good
await ctx.step("validate order", async () => {
  return validateOrder(orderId);
});

await ctx.step("process payment", async () => {
  return processPayment(paymentId);
});

// Avoid - too much in one step
await ctx.step("process everything", async () => {
  validateOrder(orderId);
  processPayment(paymentId);
  shipOrder(orderId);
  sendEmail(customerId);
});
```

### 2. Use Descriptive Names

Give steps and UI elements clear, descriptive names:

```typescript
// Good
await ctx.step("create customer record", async () => {...});
await ctx.ui.page("shipping address", {...});

// Avoid
await ctx.step("step1", async () => {...});
await ctx.ui.page("page", {...});
```

### 3. Handle Validation Properly

Validate early and provide clear error messages:

```typescript
ctx.ui.inputs.text("email", {
  label: "Email Address",
  validate: (value) => {
    if (!value) return "Email is required";
    if (!value.includes("@")) return "Invalid email format";
    if (!value.endsWith(".com")) return "Email must end with .com";
    return true;
  },
})
```

### 4. Use Stages for Complex Flows

Break complex flows into logical stages:

```typescript
export default OnboardEmployee(
  {
    stages: [
      { key: "collection", name: "Data Collection" },
      { key: "verification", name: "Verification" },
      { key: "setup", name: "Account Setup" },
    ],
  },
  async (ctx, inputs) => {
    await ctx.step("collect info", { stage: "collection" }, async () => {...});
    await ctx.step("verify identity", { stage: "verification" }, async () => {...});
    await ctx.step("create account", { stage: "setup" }, async () => {...});
  }
);
```

### 5. Configure Retries Appropriately

Use retries for transient failures, not business logic:

```typescript
// Good - retry transient network failures
await ctx.step(
  "call external api",
  { retries: 3, retryPolicy: RetryExponential(2) },
  async () => {
    return await externalAPI.fetch();
  }
);

// Avoid - don't use retries for validation
await ctx.step("validate email", async () => {
  if (!isValidEmail(email)) {
    throw new Error("Invalid email"); // This shouldn't be retried
  }
});
```

### 6. Clean Up on Failure

Use `onFailure` callbacks to clean up resources:

```typescript
await ctx.step(
  "process transaction",
  {
    retries: 3,
    onFailure: async () => {
      await models.transaction.update(
        { id: transactionId },
        { status: "failed" }
      );
      await refundCustomer(customerId);
    },
  },
  async () => {
    return processTransaction(transactionId);
  }
);
```

### 7. Return Useful Data

Return data that will be needed by subsequent steps:

```typescript
// Good - return what's needed later
const order = await ctx.step("create order", async () => {
  const order = await models.order.create({...});
  return {
    id: order.id,
    total: order.total,
    customerId: order.customerId,
  };
});

// Later steps can use order.id, order.total, etc.

// Avoid - returning too little
await ctx.step("create order", async () => {
  await models.order.create({...});
  return true; // Not useful for later steps
});
```

### 8. Test All Paths

Test both happy paths and error scenarios:

```typescript
test("successful flow", async () => {
  // Test normal completion
});

test("validation errors", async () => {
  // Test validation failures
});

test("retry and recovery", async () => {
  // Test retry logic
});

test("cancellation", async () => {
  // Test flow cancellation
});
```

### 9. Use Actions for Branching

Use page actions to create conditional flows:

```typescript
const { action } = await ctx.ui.page("decision", {
  title: "Choose an option",
  content: [...],
  actions: ["option1", "option2", "cancel"],
});

switch (action) {
  case "option1":
    await handleOption1();
    break;
  case "option2":
    await handleOption2();
    break;
  case "cancel":
    return; // Exit flow early
}
```

### 10. Document Complex Logic

Add comments to explain complex flow logic:

```typescript
export default ComplexFlow({}, async (ctx, inputs) => {
  // First, validate all inputs before any database operations
  const validation = await ctx.step("validate", async () => {
    return validateInputs(inputs);
  });

  // If validation fails, we need to notify the user and exit
  if (!validation.isValid) {
    await ctx.ui.page("error", {
      title: "Validation Failed",
      content: [
        ctx.ui.display.banner({
          content: validation.error,
          mode: "error",
        }),
      ],
    });
    return;
  }

  // Continue with main flow logic...
});
```

## Additional Resources

- Official Documentation: https://docs.keel.so/flows
- Flow Tutorial: https://docs.keel.so/internal-tools-tutorial
- Best Practices: https://docs.keel.so/flows/best-practices
- Discord Community: https://discord.gg/bxvW4QHhBx

## Notes

- Flows are currently in early preview, APIs may change
- Each step has a 15-minute timeout
- Steps execute sequentially (no concurrency support)
- Flow body failures stop execution immediately
- Function step failures trigger retries based on configuration
- Total flow duration is unlimited across steps
- All step return values must be JSON-serializable
